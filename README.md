# MURaMKit
Manipulating MURaM data for (potentially) better compression! 

This [header file](https://github.com/shaomeng/MURaMKit/blob/main/include/MURaMKit_CAPI.h) has definitions of all operations in C programming language.

## Supported conditioning operations (C)
By applying a conditioning operation, the number of data values remain the same (no compression), but they respond to lossy compression better.

### Logarithmatic and exponential transforms
- `int mkit_smart_log()` performs a logarithmatic transform on _any_ input. It does so by 1) keeping the signs of all values in a mask, and then making all negative values positive; and 2) keeping all zero values in a mask, and then applying the log transform on non-zero values. A header including up to two masks is also generated.
- `int mkit_smart_exp()` performs an exponential transform on the input. It also requires the header generated by `int mkit_smart_log()` so that it can properly restore zero and negative values.
- `size_t mkit_log_meta_len()` reads a header produced by `int mkit_smart_log()` and tells its length in bytes. 

This [utility program](https://github.com/shaomeng/MURaMKit/blob/main/utilities/smart_log.c) demonstrates their usage.

### Slice-based normalization
- `int mkit_slice_norm()` performs a slice-based normalization on a 3D volume. A **slice** is defined by the `dim_mid` and `dim_slow` dimensions of the volume. For each slice, the mean is subtracted from all values, and then all values are normalized by the RMS. A header is also generated to keep track of the mean and RMS of each slice.
- `int mkit_inv_slice_norm()` performs an inverse normalization. It requires the header generated by `int mkit_normalize()` as an input too.
- `size_t mkit_norm_meta_len()` reads a header generated by `int mkit_normalize()` and tells its length in bytes.

This [utility program](https://github.com/shaomeng/MURaMKit/blob/main/utilities/slice_norm.c) demonstrates their usage.

## Supported compression operations (C)
By applying a compression operation, the data is transformed to a different form and is only decoded by a decompressor. The data size is (hopefully) smaller though.

### Bitmask zero 
This compression operation is applicable when the original data contains a lot of zero or near-zero values. 
This operation will use a bitmask (taking one bit per value) to keep track of locations of all zero values, and only save those non-zero values verbatim. 
- `mkit_bitmask_zero()` performs the compression operation described above, and generates a bitmask together with all non-zero values.
- `mkit_inv_bitmask_zero()` uses the compressed data produced by `mkit_bitmask_zero()` and reconstructs the original data.
- `mkit_bitmask_zero_buf_len()` reads the header of the compressed data produced by `mkit_bitmask_zero()` and returns its length in bytes.

This [utility program](https://github.com/shaomeng/MURaMKit/blob/main/utilities/bitmask_zero.c) demonstrates their usage.
